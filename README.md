# Практическая работа: Дополнительные возможности Docker

## Цель работы

Изучение дополнительных возможностей Docker для управления жизненным циклом контейнеров, мониторинга их состояния и оптимизации использования системных ресурсов. Данная практика направлена на глубокое понимание операционных аспектов контейнеризации, что критически важно для построения надежных и масштабируемых приложений в production-среде.

---

##  1: Вывод логов контейнера в файл

Логирование представляет собой один из столпов наблюдаемости (observability) в современных распределенных системах. Docker предоставляет встроенные механизмы для захвата стандартных потоков вывода (stdout) и ошибок (stderr) контейнеризированного приложения, что позволяет осуществлять постмортем-анализ проблем, аудит деятельности приложения и мониторинг его работоспособности. Сохранение логов в файловую систему хоста обеспечивает персистентность этих данных за пределами жизненного цикла контейнера, тем самым предотвращая потерю критически важной информации при его остановке или удалении.

Механизм работает следующим образом: Docker демон перехватывает весь вывод, генерируемый процессами внутри контейнера, и сохраняет его в специализированных JSON-файлах логов. Посредством команды `docker logs` пользователь может получить доступ к накопленной информации, а опция перенаправления потока позволяет сохранить содержимое в файл хоста для последующего анализа, архивирования или интеграции с внешними системами логирования.

### Практическое применение

Данная функциональность нередко применяется в следующих сценариях:

- **Диагностика сбоев**: При обнаружении неиспправности в production-среде логи позволяют восстановить цепь событий, предшествовавшую отказу
- **Аудит безопасности**: Сохранение логов в защищенном хранилище обеспечивает учет всех значительных событий
- **Анализ производительности**: Логи содержат информацию о времени выполнения операций и использовании ресурсов
- **Интеграция с системами мониторинга**: Агенты сбора логов (например, Filebeat, Logstash) могут работать с файлами логов для их централизации

### Примеры команд

```bash
# Базовый вывод логов контейнера
docker logs container_name

# Сохранение логов в файл
docker logs container_name > logs.txt

# Сохранение логов с временными метками
docker logs --timestamps container_name > logs_with_timestamps.txt

# Получение последних N строк логов
docker logs --tail 50 container_name > recent_logs.txt

# Отслеживание логов в реальном времени (аналог tail -f)
docker logs -f container_name

# Отслеживание логов с их сохранением одновременно
docker logs -f container_name | tee live_logs.txt
```

---

## 2. Проверка docker-stats

Мониторинг потребления системных ресурсов контейнерами является неотъемлемым компонентом операционного управления Docker-инфраструктурой. Команда `docker stats` предоставляет real-time метрики, отражающие текущее использование контейнером памяти (RAM), процессорного времени (CPU), сетевого ввода-вывода и операций чтения-записи дискового устройства. Эти показатели критически важны для принятия обоснованных решений о масштабировании, выявления "прожорливых" приложений и диагностики проблем с производительностью.

Архитектурно, Docker stats получает информацию из контрольных групп ядра Linux (cgroups), которые позволяют отслеживать и ограничивать потребление ресурсов отдельными процессами. Система работает на уровне операционного ядра, обеспечивая высокую точность и минимальные накладные расходы на сбор метрик.

### Практическое применение

Данный инструмент решает следующие задачи:

- **Идентификация bottlenecks**: Определение того, какие контейнеры потребляют непропорционально большое количество ресурсов
- **Емкостное планирование**: Сбор исторических данных о потреблении ресурсов для прогнозирования будущих потребностей инфраструктуры
- **Оптимизация конфигурации**: Обнаружение неэффективности в распределении ресурсов при запуске контейнеров
- **Детектирование утечек памяти**: Наблюдение за постоянным ростом потребления памяти приложением с течением времени

### Примеры команд

```bash
# Просмотр статистики всех работающих контейнеров
docker stats

# Просмотр статистики конкретного контейнера
docker stats container_name

# Просмотр статистики нескольких контейнеров
docker stats container1 container2 container3

# Вывод статистики без обновления (один снимок)
docker stats --no-stream

# Сохранение статистики в файл (снимок в текущий момент)
docker stats --no-stream > stats.txt

# Сохранение статистики в формате таблицы с фиксированным интервалом
docker stats --no-stream > stats_snapshot.txt
```

---

## 3. Ограничение контейнера по CPU и Memory

Ограничение системных ресурсов, выделяемых контейнерам, представляет собой критически важный механизм для обеспечения справедливого распределения вычислительных мощностей в многоконтейнерной среде и предотвращения сценариев "noisy neighbor", когда один неоптимизированный контейнер может монополизировать ресурсы и деградировать производительность соседних приложений.

Docker использует фундаментальные Linux-возможности в виде контрольных групп (cgroups) версии 1 и 2 для реализации этого механизма. При установке лимита на память контейнер получает жесткую верхнюю границу (hard limit), при превышении которой процессы будут завершены ядром операционной системы посредством OOM-killer. Для CPU доступны два подхода: установка доли процессорного времени (shares) для пропорционального распределения или задание конкретного количества CPU cores (в виде дробных значений), к которым контейнер имеет доступ.

Механизм работает следующим образом: ядро Linux отслеживает потребление ресурсов для каждой cgroup, и при попытке превышить установленные лимиты, система применяет соответствующие ограничения (throttling для CPU или termination для памяти). Данный подход обеспечивает качество обслуживания (QoS) и гарантирует предсказуемое поведение приложения независимо от активности других сервисов.

### Практическое применение

Ограничение ресурсов необходимо в следующих контекстах:

- **Предотвращение DoS-атак**: Ограничение ресурсов хостированных приложений пользователей защищает хост от полного исчерпания ресурсов
- **Разделение ресурсов в мультитенант-среде**: Обеспечение справедливого распределения CPU и памяти между несколькими приложениями
- **Testing и staging**: Воспроизведение production-конфигурации в целях выявления проблем с производительностью на ранних этапах
- **Оптимизация затрат**: Более эффективное использование серверного оборудования через выявление оптимального количества ресурсов для каждого приложения
- **Гарантии SLA**: Обеспечение минимальных гарантий производительности критических приложений

### Примеры команд

```bash
# Ограничение памяти контейнера
docker run -d --name memory-limited --memory=512m ubuntu sleep 3600

# Ограничение памяти с минимальной гарантией (memory reservation)
docker run -d --name memory-reserved --memory=512m --memory-reservation=256m ubuntu sleep 3600

# Ограничение CPU (количество cores)
docker run -d --name cpu-limited --cpus=1.5 ubuntu sleep 3600

# Ограничение CPU shares (пропорциональное распределение)
docker run -d --name cpu-shared --cpu-shares=512 ubuntu sleep 3600

# Комбинированное ограничение памяти и CPU
docker run -d --name limited-container --memory=512m --cpus=1 ubuntu sleep 3600

# Ограничение swap-памяти
docker run -d --name swap-limited --memory=512m --memory-swap=768m ubuntu sleep 3600

# Применение ограничений к существующему контейнеру
docker update --memory=1g --cpus=2 container_name
```

---

## 4. Сохранение docker-контейнера в tar

Механизм экспорта контейнера в архив tar представляет собой способ создания портативной копии полной файловой системы контейнера со всеми его файлами и изменениями, которые были произведены с момента его запуска на основе образа. Эта операция часто используется для целей миграции, когда требуется перенести контейнер между хостами, архивирования, когда необходимо сохранить снимок состояния приложения, или восстановления после сбоя.

Под капотом Docker создает снимок всех слоев (layers) образа, включая любые изменения в контейнере, и упаковывает их в единый tar-архив. Важно понимать, что при экспорте сохраняется именно файловая система контейнера в его текущем состоянии, а не история слоев образа. Это означает, что восстановленный из архива контейнер не будет иметь исходной истории сборки образа, но будет функционально идентичен исходному контейнеру на момент экспорта.

### Практическое применение

Данная функциональность применяется в следующих сценариях:

- **Миграция рабочих нагрузок**: Перенос настроенного и работающего контейнера между различными хостами или облачными провайдерами
- **Резервное копирование состояния**: Создание полной копии контейнера с целью восстановления его в случае потери данных или аварийного отказа
- **Отладка в offline-режиме**: Сохранение контейнера для последующего детального анализа его содержимого на отдельной машине
- **Обмен рабочими средами**: Передача настроенного окружения разработки между членами команды через простой файл архива

### Примеры команд

```bash
# Базовый экспорт контейнера в tar
docker export container_name > container_backup.tar

# Экспорт контейнера с сжатием (gzip)
docker export container_name | gzip > container_backup.tar.gz

# Экспорт контейнера с альтернативными алгоритмами сжатия
docker export container_name | bzip2 > container_backup.tar.bz2

# Сохранение архива в конкретную директорию
docker export container_name > /tmp/container_backup.tar

# Просмотр содержимого архива без распаковки
tar -tzf container_backup.tar.gz | head -20

# Получение размера архива
ls -lh container_backup.tar
```

---

## Часть 5: Загрузка контейнера из tar

Операция импорта контейнера из tar-архива является обратной процедурой к экспорту. При загрузке архива Docker создает новый образ на основе файловой системы, содержащейся в tar, что позволяет восстановить полное состояние контейнера, включая все установленные пакеты, конфигурационные файлы и данные приложения. Этот процесс эффективен для восстановления после сбоев, миграции между инфраструктурами и воспроизведения специфических рабочих окружений в различных сценариях.

Архитектурно, операция `docker import` принимает tar-поток и преобразует его в образ Docker, который может быть затем использован для запуска новых контейнеров. При импорте создается новый слой (layer), содержащий всю файловую систему из архива. Впоследствии этот образ может быть использован для создания множества контейнеров, что обеспечивает эффективное повторное использование и масштабирование.

### Практическое применение

Загрузка из архива используется в следующих ситуациях:

- **Восстановление из резервной копии**: При потере контейнера или хоста можно восстановить полное состояние приложения из ранее созданного архива
- **Воспроизведение известного состояния**: Создание идентичных копий контейнера для целей тестирования, development и production-сред
- **Распределение настроенного окружения**: Быстрая доставка готового рабочего окружения на новые машины через простой файл
- **Миграция между версиями Docker**: Гарантия совместимости образов при переходе на новые версии платформы

### Примеры команд

```bash
# Загрузка контейнера из архива в новый образ
docker import container_backup.tar restored-image

# Загрузка сжатого архива
cat container_backup.tar.gz | gunzip | docker import - restored-image-compressed

# Загрузка архива с указанием имени и тега
docker import container_backup.tar restored-image:v1.0

# Запуск контейнера из загруженного образа
docker run -d --name restored-container restored-image /bin/bash -c "sleep 3600"

# Проверка загруженного образа в списке локальных образов
docker images | grep restored

# Удаление временного образа
docker rmi restored-image
```

---

## Dockerfile для практической работы

```dockerfile
# Используется базовый образ на основе Alpine Linux для минимизации размера
FROM alpine:3.18

# Установка необходимых утилит для работы практики
RUN apk add --no-cache \
    bash \
    curl \
    htop \
    procps

# Создание пользователя без привилегий администратора для повышения безопасности
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# Установка рабочей директории
WORKDIR /home/appuser

# Копирование скрипта логирования в контейнер
COPY --chown=appuser:appuser entrypoint.sh /home/appuser/

# Предоставление прав на выполнение скрипта
RUN chmod +x /home/appuser/entrypoint.sh

# Переключение на непривилегированного пользователя
USER appuser

# Точка входа контейнера - выполняет логирование и мониторинг
ENTRYPOINT ["/home/appuser/entrypoint.sh"]

# Значение по умолчанию - время работы в секундах
CMD ["60"]
```

### Скрипт entrypoint.sh

```bash
#!/bin/bash

DURATION=${1:-60}

echo "====== Docker Practice Container ======"
echo "Start time: $(date)"
echo "Duration: ${DURATION} seconds"
echo "========================================"

# Вывод информации о системе
echo "System Information:"
uname -a
echo "Available Memory: $(free -h | grep Mem)"
echo "CPU Info:"
nproc

# Генерируем логи и нагрузку на ресурсы
counter=0
while [ $counter -lt $DURATION ]; do
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Iteration $((counter + 1))/$DURATION"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Memory usage: $(ps aux | awk '{sum+=$6} END {print sum/1024 " MB"}')"
    
    # Имитация работы приложения
    sleep 5
    counter=$((counter + 5))
done

echo "====== Container Shutdown ======"
echo "End time: $(date)"
echo "Container completed successfully"
```
<img width="1093" height="200" alt="Снимок экрана 2025-12-23 в 22 50 14" src="https://github.com/user-attachments/assets/832484ca-64a0-4c87-9559-0cbc91935205" />

---

## Инструкция по выполнению практики

### Подготовка окружения

```bash
# Создание директории для практики
mkdir docker-practice
cd docker-practice

# Копирование Dockerfile и entrypoint.sh в директорию
# (файлы должны быть созданы согласно примерам выше)

# Сборка образа
docker build -t practice-image:1.0 .
```

### Задание 1: Вывод логов в файл

```bash
# Запуск контейнера
docker run -d --name practice-container-1 practice-image:1.0 30

# Ожидание завершения контейнера
sleep 35

# Сохранение логов
docker logs practice-container-1 > /tmp/container_logs.txt

# Просмотр логов
cat /tmp/container_logs.txt

# Очистка
docker rm practice-container-1
```

### Задание 2: Проверка docker-stats

```bash
# Запуск контейнера в background
docker run -d --name practice-container-2 practice-image:1.0 45

# В другом терминале: просмотр статистики в реальном времени
docker stats practice-container-2

# Или сохранение одного снимка статистики
docker stats --no-stream practice-container-2 > /tmp/container_stats.txt

# После завершения контейнера
docker rm practice-container-2
```

### Задание 3: Ограничение ресурсов

```bash
# Запуск контейнера с ограничением памяти и CPU
docker run -d --name practice-limited \
  --memory=256m \
  --cpus=0.5 \
  practice-image:1.0 60

# Проверка статистики с учетом лимитов
docker stats --no-stream practice-limited

# Обновление лимитов на работающем контейнере
docker update --memory=512m practice-limited

# Очистка
docker stop practice-limited
docker rm practice-limited
```

### Задание 4: Экспорт в tar

```bash
# Запуск контейнера и ожидание его завершения
docker run -d --name practice-export practice-image:1.0 30

# Ожидание завершения
sleep 35

# Экспорт контейнера в tar
docker export practice-export > /tmp/container_export.tar

# Проверка размера архива
ls -lh /tmp/container_export.tar

# Просмотр содержимого архива
tar -tf /tmp/container_export.tar | head -20

# Очистка
docker rm practice-export
```

### Задание 5: Импорт из tar

```bash
# Загрузка образа из архива
docker import /tmp/container_export.tar restored-practice:1.0

# Проверка наличия образа
docker images | grep restored

# Запуск контейнера из загруженного образа
docker run -d --name restored-from-tar restored-practice:1.0 30

# Проверка логов восстановленного контейнера
sleep 35
docker logs restored-from-tar

# Очистка
docker stop restored-from-tar
docker rm restored-from-tar
docker rmi restored-practice:1.0
```

---

## Контрольные вопросы для самопроверки

1. Какие потоки данных перехватывает Docker при логировании и почему это важно для диагностики?
2. Каким образом контрольные группы (cgroups) Linux обеспечивают ограничение ресурсов в Docker?
3. Чем отличается экспорт контейнера от сохранения образа, и в каких сценариях применяется каждый подход?
4. Почему важно устанавливать ограничения памяти для контейнеров в многоконтейнерной среде?
5. Какие метрики предоставляет `docker stats` и как их интерпретировать для оптимизации производительности?
6. Как восстановить контейнер из tar-архива и какие ограничения существуют при этом процессе?
7. Каким образом можно использовать экспорт контейнеров для миграции приложений между хостами?
